\section{OGGZ Write API}
\label{group__write__api}\index{OGGZ Write API@{OGGZ Write API}}


\subsection{Detailed Description}
OGGZ maintains a packet queue, such that you can independently add packets to the queue and write an Ogg bitstream. 

There are two complementary methods for adding packets to the packet queue.

\begin{itemize}
\item by {\bf force feeding OGGZ }{\rm (p.\,\pageref{group__force__feed})}\item by using {\bf Oggz\-Hungry }{\rm (p.\,\pageref{group__hungry})} callbacks\end{itemize}


As each packet is enqueued, its validity is checked against the framing constraints outlined in the {\bf Ogg basics }{\rm (p.\,\pageref{group__basics})} section. If it does not pass these constraints, {\bf oggz\_\-write\_\-feed()}{\rm (p.\,\pageref{group__write__api_ga2})} will fail with an appropriate error code.

\begin{Desc}
\item[Note:]\begin{itemize}
\item When writing, you can ensure that a packet starts on a new page by setting the {\em flush\/} parameter of {\bf oggz\_\-write\_\-feed()}{\rm (p.\,\pageref{group__write__api_ga2})} to {\em OGGZ\_\-FLUSH\_\-BEFORE\/} when enqueuing it. Similarly you can ensure that the last page a packet is written into won't contain any following packets by setting the {\em flush\/} parameter of {\bf oggz\_\-write\_\-feed()}{\rm (p.\,\pageref{group__write__api_ga2})} to {\em OGGZ\_\-FLUSH\_\-AFTER\/}.\item The {\em OGGZ\_\-FLUSH\_\-BEFORE\/} and {\em OGGZ\_\-FLUSH\_\-AFTER\/} flags can be bitwise OR'd together to ensure that the packet will not share any pages with any other packets, either before or after. \end{itemize}
\end{Desc}


\subsection*{Typedefs}
\begin{CompactItemize}
\item 
typedef int($\ast$ {\bf Oggz\-Write\-Hungry} )({\bf OGGZ} $\ast$oggz, int empty, void $\ast$user\_\-data)
\begin{CompactList}\small\item\em This is the signature of a callback which Oggz will call when {\em oggz\/} is {\bf hungry }{\rm (p.\,\pageref{group__hungry})}. \item\end{CompactList}\end{CompactItemize}
\subsection*{Functions}
\begin{CompactItemize}
\item 
int {\bf oggz\_\-write\_\-set\_\-hungry\_\-callback} ({\bf OGGZ} $\ast$oggz, {\bf Oggz\-Write\-Hungry} hungry, int only\_\-when\_\-empty, void $\ast$user\_\-data)
\begin{CompactList}\small\item\em Set a callback for Oggz to call when {\em oggz\/} is {\bf hungry }{\rm (p.\,\pageref{group__hungry})}. \item\end{CompactList}\item 
int {\bf oggz\_\-write\_\-feed} ({\bf OGGZ} $\ast$oggz, ogg\_\-packet $\ast$op, long serialno, int flush, int $\ast$guard)
\begin{CompactList}\small\item\em Add a packet to {\em oggz's\/} packet queue. \item\end{CompactList}\item 
long {\bf oggz\_\-write\_\-output} ({\bf OGGZ} $\ast$oggz, unsigned char $\ast$buf, long n)
\begin{CompactList}\small\item\em Output data from an OGGZ handle. \item\end{CompactList}\item 
long {\bf oggz\_\-write} ({\bf OGGZ} $\ast$oggz, long n)
\begin{CompactList}\small\item\em Write n bytes from an OGGZ handle. \item\end{CompactList}\item 
long {\bf oggz\_\-write\_\-get\_\-next\_\-page\_\-size} ({\bf OGGZ} $\ast$oggz)
\begin{CompactList}\small\item\em Query the number of bytes in the next page to be written. \item\end{CompactList}\end{CompactItemize}


\subsection{Typedef Documentation}
\index{write_api@{write\_\-api}!OggzWriteHungry@{OggzWriteHungry}}
\index{OggzWriteHungry@{OggzWriteHungry}!write_api@{write\_\-api}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}typedef int($\ast$ {\bf Oggz\-Write\-Hungry})({\bf OGGZ} $\ast$ oggz, int empty, void $\ast$ user\_\-data)}\label{group__write__api_ga0}


This is the signature of a callback which Oggz will call when {\em oggz\/} is {\bf hungry }{\rm (p.\,\pageref{group__hungry})}. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em oggz}]The OGGZ handle \item[{\em empty}]A value of 1 indicates that the packet queue is currently empty. A value of 0 indicates that the packet queue is not empty. \item[{\em user\_\-data}]A generic pointer you have provided earlier \end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em 0}]Continue \item[{\em non-zero}]Instruct OGGZ to stop. \end{description}
\end{Desc}


\subsection{Function Documentation}
\index{write_api@{write\_\-api}!oggz_write@{oggz\_\-write}}
\index{oggz_write@{oggz\_\-write}!write_api@{write\_\-api}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}long oggz\_\-write ({\bf OGGZ} $\ast$ {\em oggz}, long {\em n})}\label{group__write__api_ga4}


Write n bytes from an OGGZ handle. 

Oggz will call your write callback as needed.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em oggz}]An OGGZ handle previously opened for writing \item[{\em n}]A count of bytes to be written \end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em $>$ 0}]The number of bytes successfully output \item[{\em 0}]End of stream \item[{\em OGGZ\_\-ERR\_\-RECURSIVE\_\-WRITE}]Attempt to initiate writing from within an Oggz\-Hungry callback \item[{\em OGGZ\_\-ERR\_\-BAD\_\-OGGZ}]{\em oggz\/} does not refer to an existing OGGZ \item[{\em OGGZ\_\-ERR\_\-INVALID}]Operation not suitable for this OGGZ \end{description}
\end{Desc}
\index{write_api@{write\_\-api}!oggz_write_feed@{oggz\_\-write\_\-feed}}
\index{oggz_write_feed@{oggz\_\-write\_\-feed}!write_api@{write\_\-api}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int oggz\_\-write\_\-feed ({\bf OGGZ} $\ast$ {\em oggz}, ogg\_\-packet $\ast$ {\em op}, long {\em serialno}, int {\em flush}, int $\ast$ {\em guard})}\label{group__write__api_ga2}


Add a packet to {\em oggz's\/} packet queue. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em oggz}]An OGGZ handle previously opened for writing \item[{\em op}]An ogg\_\-packet with all fields filled in \item[{\em serialno}]Identify the logical bitstream in {\em oggz\/} to add the packet to \item[{\em flush}]Bitmask of OGGZ\_\-FLUSH\_\-BEFORE, OGGZ\_\-FLUSH\_\-AFTER \item[{\em guard}]A guard for nocopy, NULL otherwise \end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em 0}]Success \item[{\em OGGZ\_\-ERR\_\-BAD\_\-GUARD}]{\em guard\/} specified has non-zero initialization \item[{\em OGGZ\_\-ERR\_\-BOS}]Packet would be bos packet of a new logical bitstream, but oggz has already written one or more non-bos packets in other logical bitstreams, and {\em oggz\/} is not flagged OGGZ\_\-NONSTRICT \item[{\em OGGZ\_\-ERR\_\-EOS}]The logical bitstream identified by {\em serialno\/} is already at eos, and {\em oggz\/} is not flagged OGGZ\_\-NONSTRICT \item[{\em OGGZ\_\-ERR\_\-BAD\_\-BYTES}]{\em op-$>$bytes\/} is invalid, and {\em oggz\/} is not flagged OGGZ\_\-NONSTRICT \item[{\em OGGZ\_\-ERR\_\-BAD\_\-B\_\-O\_\-S}]{\em op-$>$b\_\-o\_\-s\/} is invalid, and {\em oggz\/} is not flagged OGGZ\_\-NONSTRICT \item[{\em OGGZ\_\-ERR\_\-BAD\_\-GRANULEPOS}]{\em op-$>$granulepos\/} is less than that of an earlier packet within this logical bitstream, and {\em oggz\/} is not flagged OGGZ\_\-NONSTRICT \item[{\em OGGZ\_\-ERR\_\-BAD\_\-PACKETNO}]{\em op-$>$packetno\/} is less than that of an earlier packet within this logical bitstream, and {\em oggz\/} is not flagged OGGZ\_\-NONSTRICT \item[{\em OGGZ\_\-ERR\_\-BAD\_\-SERIALNO}]{\em serialno\/} does not identify an existing logical bitstream in {\em oggz\/}, and {\em oggz\/} is not flagged OGGZ\_\-NONSTRICT \item[{\em OGGZ\_\-ERR\_\-BAD\_\-OGGZ}]{\em oggz\/} does not refer to an existing OGGZ \item[{\em OGGZ\_\-ERR\_\-INVALID}]Operation not suitable for this OGGZ\end{description}
\end{Desc}
\begin{Desc}
\item[Note:]If {\em op-$>$b\_\-o\_\-s\/} is initialized to {\em -1\/} before calling {\bf oggz\_\-write\_\-feed()}{\rm (p.\,\pageref{group__write__api_ga2})}, Oggz will fill it in with the appropriate value; ie. 1 for the first packet of a new stream, and 0 otherwise. \end{Desc}
\index{write_api@{write\_\-api}!oggz_write_get_next_page_size@{oggz\_\-write\_\-get\_\-next\_\-page\_\-size}}
\index{oggz_write_get_next_page_size@{oggz\_\-write\_\-get\_\-next\_\-page\_\-size}!write_api@{write\_\-api}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}long oggz\_\-write\_\-get\_\-next\_\-page\_\-size ({\bf OGGZ} $\ast$ {\em oggz})}\label{group__write__api_ga5}


Query the number of bytes in the next page to be written. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em oggz}]An OGGZ handle previously opened for writing \end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em $>$= 0}]The number of bytes in the next page \item[{\em OGGZ\_\-ERR\_\-BAD\_\-OGGZ}]{\em oggz\/} does not refer to an existing OGGZ \item[{\em OGGZ\_\-ERR\_\-INVALID}]Operation not suitable for this OGGZ \end{description}
\end{Desc}
\index{write_api@{write\_\-api}!oggz_write_output@{oggz\_\-write\_\-output}}
\index{oggz_write_output@{oggz\_\-write\_\-output}!write_api@{write\_\-api}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}long oggz\_\-write\_\-output ({\bf OGGZ} $\ast$ {\em oggz}, unsigned char $\ast$ {\em buf}, long {\em n})}\label{group__write__api_ga3}


Output data from an OGGZ handle. 

Oggz will call your write callback as needed.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em oggz}]An OGGZ handle previously opened for writing \item[{\em buf}]A memory buffer \item[{\em n}]A count of bytes to output \end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em $>$ 0}]The number of bytes successfully output \item[{\em 0}]End of stream \item[{\em OGGZ\_\-ERR\_\-RECURSIVE\_\-WRITE}]Attempt to initiate writing from within an Oggz\-Hungry callback \item[{\em OGGZ\_\-ERR\_\-BAD\_\-OGGZ}]{\em oggz\/} does not refer to an existing OGGZ \item[{\em OGGZ\_\-ERR\_\-INVALID}]Operation not suitable for this OGGZ \end{description}
\end{Desc}
\index{write_api@{write\_\-api}!oggz_write_set_hungry_callback@{oggz\_\-write\_\-set\_\-hungry\_\-callback}}
\index{oggz_write_set_hungry_callback@{oggz\_\-write\_\-set\_\-hungry\_\-callback}!write_api@{write\_\-api}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int oggz\_\-write\_\-set\_\-hungry\_\-callback ({\bf OGGZ} $\ast$ {\em oggz}, {\bf Oggz\-Write\-Hungry} {\em hungry}, int {\em only\_\-when\_\-empty}, void $\ast$ {\em user\_\-data})}\label{group__write__api_ga1}


Set a callback for Oggz to call when {\em oggz\/} is {\bf hungry }{\rm (p.\,\pageref{group__hungry})}. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em oggz}]An OGGZ handle previously opened for writing \item[{\em hungry}]Your callback function \item[{\em only\_\-when\_\-empty}]When to call: a value of 0 indicates that OGGZ should call {\em hungry()\/} after each and every packet is written; a value of 1 indicates that OGGZ should call {\em hungry()\/} only when its packet queue is empty \item[{\em user\_\-data}]Arbitrary data you wish to pass to your callback \end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em 0}]Success \item[{\em OGGZ\_\-ERR\_\-BAD\_\-OGGZ}]{\em oggz\/} does not refer to an existing OGGZ \item[{\em OGGZ\_\-ERR\_\-INVALID}]Operation not suitable for this OGGZ \end{description}
\end{Desc}
\begin{Desc}
\item[Note:]Passing a value of 0 for {\em only\_\-when\_\-empty\/} allows you to feed new packets into {\em oggz's\/} packet queue on the fly. \end{Desc}
