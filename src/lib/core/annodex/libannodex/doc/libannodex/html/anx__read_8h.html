<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libannodex: anx_read.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>anx_read.h File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
libannodex provides a convenient callback based framework for reading Annodex media. 
<p>
After opening an annodex for reading, you can attach various callbacks relevant to the parts of the file you are interested in, including the stream header, track headers, head element, clips and media data. Then, as bytes are read, libannodex will call your callbacks as appropriate.<p>
For tutorial information and examples, refer to the following:<p>
<ul>
<li><a class="el" href="group__reading__files.html">Reading from files and file descriptors </a></li><li><a class="el" href="group__reading__memory.html">Reading from memory buffers </a></li><li><a class="el" href="group__reading__callbacks.html">Advanced management of AnxRead* callbacks </a></li></ul>

<p>
<code>#include &lt;<a class="el" href="anx__types_8h-source.html">annodex/anx_types.h</a>&gt;</code><br>

<p>
<a href="anx__read_8h-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef int(*&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="anx__read_8h.html#a0">AnxReadStream</a> )(<a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *annodex, double timebase, char *utc, void *user_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signature for a callback called when the 'Annodex' stream header is parsed.  <a href="#a0"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef int(*&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="anx__read_8h.html#a1">AnxReadTrack</a> )(<a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *annodex, long serialno, char *id, char *content_type, <a class="el" href="anx__int64_8h.html#a0">anx_int64_t</a> granule_rate_n, <a class="el" href="anx__int64_8h.html#a0">anx_int64_t</a> granule_rate_d, int nr_header_packets, void *user_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signature for a callback called each time an 'AnxData' track header is parsed.  <a href="#a1"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef int(*&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="anx__read_8h.html#a2">AnxReadHead</a> )(<a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *annodex, const AnxHead *head, void *user_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signature for a callback called when the head element is parsed.  <a href="#a2"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef int(*&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="anx__read_8h.html#a3">AnxReadClip</a> )(<a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *annodex, const AnxClip *clip, void *user_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signature for a callback called each time a clip element is parsed.  <a href="#a3"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef int(*&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="anx__read_8h.html#a4">AnxReadRaw</a> )(<a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *annodex, unsigned char *data, long n, long serialno, <a class="el" href="anx__int64_8h.html#a0">anx_int64_t</a> granulepos, void *user_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signature for a callback called each time a raw data packet is found.  <a href="#a4"></a><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="anx__read_8h.html#a5">anx_set_read_stream_callback</a> (<a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *annodex, <a class="el" href="anx__read_8h.html#a0">AnxReadStream</a> read_stream, void *user_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the function to call each time an 'Annodex' stream header is parsed.  <a href="#a5"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="anx__read_8h.html#a6">anx_get_read_stream_user_data</a> (<a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *annodex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the user_data associated with an attached AnxReadStream callback.  <a href="#a6"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="anx__read_8h.html#a7">anx_set_read_track_callback</a> (<a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *annodex, <a class="el" href="anx__read_8h.html#a1">AnxReadTrack</a> read_track, void *user_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the function to call each time an 'AnxData' track header is parsed.  <a href="#a7"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="anx__read_8h.html#a8">anx_get_read_track_user_data</a> (<a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *annodex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the user_data associated with an attached AnxReadTrack callback.  <a href="#a8"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="anx__read_8h.html#a9">anx_set_read_head_callback</a> (<a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *annodex, <a class="el" href="anx__read_8h.html#a2">AnxReadHead</a> read_head, void *user_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the function to call when the head element is read.  <a href="#a9"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="anx__read_8h.html#a10">anx_get_read_head_user_data</a> (<a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *annodex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the user_data associated with an attached AnxReadHead callback.  <a href="#a10"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="anx__read_8h.html#a11">anx_set_read_clip_callback</a> (<a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *annodex, <a class="el" href="anx__read_8h.html#a3">AnxReadClip</a> read_clip, void *user_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the function to call each time a clip is parsed.  <a href="#a11"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="anx__read_8h.html#a12">anx_get_read_clip_user_data</a> (<a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *annodex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the user_data associated with an attached AnxReadClip callback.  <a href="#a12"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="anx__read_8h.html#a13">anx_set_read_raw_callback</a> (<a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *annodex, <a class="el" href="anx__read_8h.html#a4">AnxReadRaw</a> read_raw, void *user_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the function to call each time a raw data packet is read.  <a href="#a13"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="anx__read_8h.html#a14">anx_get_read_raw_user_data</a> (<a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *annodex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the user_data associated with an attached AnxReadRaw callback.  <a href="#a14"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="anx__read_8h.html#a15">anx_set_user_data</a> (<a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *annodex, void *user_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Associate arbitrary data with read callbacks.  <a href="#a15"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="anx__read_8h.html#a16">anx_read</a> (<a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *annodex, long n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read from an annodex opened with <a class="el" href="anx__general_8h.html#a3">anx_open()</a> or <a class="el" href="anx__general_8h.html#a4">anx_open_stdio()</a>.  <a href="#a16"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>long&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="anx__read_8h.html#a17">anx_read_input</a> (<a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *annodex, unsigned char *buf, long n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Input data from a memory buffer into an annodex.  <a href="#a17"></a><br><br></td></tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="a3" doxytag="anx_read.h::AnxReadClip" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef int(* <a class="el" href="anx__read_8h.html#a3">AnxReadClip</a>)(<a class="el" href="anx__types_8h.html#a0">ANNODEX</a> * annodex, const AnxClip * clip, void * user_data)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Signature for a callback called each time a clip element is parsed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>annodex</em>&nbsp;</td><td>the ANNODEX* handle in use </td></tr>
    <tr><td valign=top><em>clip</em>&nbsp;</td><td>the clip element </td></tr>
    <tr><td valign=top><em>user_data</em>&nbsp;</td><td>A generic pointer you have provided earlier </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>ANX_CONTINUE on success, and to inform anx_read*() functions to continue on to the next packet</li><li>ANX_STOP_OK on success, to inform anx_read*() functions to return without further processing</li><li>ANX_STOP_ERR on error, to inform anx_read*() functions to return without further processing </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="anx_read.h::AnxReadHead" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef int(* <a class="el" href="anx__read_8h.html#a2">AnxReadHead</a>)(<a class="el" href="anx__types_8h.html#a0">ANNODEX</a> * annodex, const AnxHead * head, void * user_data)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Signature for a callback called when the head element is parsed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>annodex</em>&nbsp;</td><td>the ANNODEX* handle in use </td></tr>
    <tr><td valign=top><em>head</em>&nbsp;</td><td>the head element </td></tr>
    <tr><td valign=top><em>user_data</em>&nbsp;</td><td>A generic pointer you have provided earlier </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>ANX_CONTINUE on success, and to inform anx_read*() functions to continue on to the next packet</li><li>ANX_STOP_OK on success, to inform anx_read*() functions to return without further processing</li><li>ANX_STOP_ERR on error, to inform anx_read*() functions to return without further processing </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="anx_read.h::AnxReadRaw" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef int(* <a class="el" href="anx__read_8h.html#a4">AnxReadRaw</a>)(<a class="el" href="anx__types_8h.html#a0">ANNODEX</a> * annodex, unsigned char * data, long n, long serialno, <a class="el" href="anx__int64_8h.html#a0">anx_int64_t</a> granulepos, void * user_data)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Signature for a callback called each time a raw data packet is found. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>annodex</em>&nbsp;</td><td>the ANNODEX* handle in use </td></tr>
    <tr><td valign=top><em>data</em>&nbsp;</td><td>a pointer to the data read from the packet </td></tr>
    <tr><td valign=top><em>n</em>&nbsp;</td><td>the length in bytes of the data </td></tr>
    <tr><td valign=top><em>serialno</em>&nbsp;</td><td>the track serial number of the packet </td></tr>
    <tr><td valign=top><em>granulepos</em>&nbsp;</td><td>the granule position of the packet </td></tr>
    <tr><td valign=top><em>user_data</em>&nbsp;</td><td>A generic pointer you have provided earlier </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>ANX_CONTINUE on success, and to inform anx_read*() functions to continue on to the next packet</li><li>ANX_STOP_OK on success, to inform anx_read*() functions to return without further processing</li><li>ANX_STOP_ERR on error, to inform anx_read*() functions to return without further processing </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="anx_read.h::AnxReadStream" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef int(* <a class="el" href="anx__read_8h.html#a0">AnxReadStream</a>)(<a class="el" href="anx__types_8h.html#a0">ANNODEX</a> * annodex, double timebase, char * utc, void * user_data)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Signature for a callback called when the 'Annodex' stream header is parsed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>annodex</em>&nbsp;</td><td>the ANNODEX* handle in use </td></tr>
    <tr><td valign=top><em>timebase</em>&nbsp;</td><td>the timebase of the annodex </td></tr>
    <tr><td valign=top><em>utc</em>&nbsp;</td><td>the UTC timebase of the annodex </td></tr>
    <tr><td valign=top><em>user_data</em>&nbsp;</td><td>A generic pointer you have provided earlier </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>ANX_CONTINUE on success, and to inform anx_read*() functions to continue on to the next packet</li><li>ANX_STOP_OK on success, to inform anx_read*() functions to return without further processing</li><li>ANX_STOP_ERR on error, to inform anx_read*() functions to return without further processing </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="anx_read.h::AnxReadTrack" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef int(* <a class="el" href="anx__read_8h.html#a1">AnxReadTrack</a>)(<a class="el" href="anx__types_8h.html#a0">ANNODEX</a> * annodex, long serialno, char * id, char * content_type, <a class="el" href="anx__int64_8h.html#a0">anx_int64_t</a> granule_rate_n, <a class="el" href="anx__int64_8h.html#a0">anx_int64_t</a> granule_rate_d, int nr_header_packets, void * user_data)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Signature for a callback called each time an 'AnxData' track header is parsed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>annodex</em>&nbsp;</td><td>the ANNODEX* handle in use </td></tr>
    <tr><td valign=top><em>serialno</em>&nbsp;</td><td>the track serial number </td></tr>
    <tr><td valign=top><em>id</em>&nbsp;</td><td>the id attribute of the track </td></tr>
    <tr><td valign=top><em>content_type</em>&nbsp;</td><td>the content type of the track </td></tr>
    <tr><td valign=top><em>granule_rate_n</em>&nbsp;</td><td>the numerator of the granule rate </td></tr>
    <tr><td valign=top><em>granule_rate_d</em>&nbsp;</td><td>the denominator of the granule rate </td></tr>
    <tr><td valign=top><em>nr_header_packets</em>&nbsp;</td><td>the number of header packets of the track </td></tr>
    <tr><td valign=top><em>user_data</em>&nbsp;</td><td>A generic pointer you have provided earlier </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>ANX_CONTINUE on success, and to inform anx_read*() functions to continue on to the next packet</li><li>ANX_STOP_OK on success, to inform anx_read*() functions to return without further processing</li><li>ANX_STOP_ERR on error, to inform anx_read*() functions to return without further processing </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a12" doxytag="anx_read.h::anx_get_read_clip_user_data" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void* anx_get_read_clip_user_data </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>annodex</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve the user_data associated with an attached AnxReadClip callback. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>annodex</em>&nbsp;</td><td>an ANNODEX* handle </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the associated user_data </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="anx_read.h::anx_get_read_head_user_data" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void* anx_get_read_head_user_data </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>annodex</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve the user_data associated with an attached AnxReadHead callback. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>annodex</em>&nbsp;</td><td>an ANNODEX* handle </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the associated user_data </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="anx_read.h::anx_get_read_raw_user_data" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void* anx_get_read_raw_user_data </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>annodex</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve the user_data associated with an attached AnxReadRaw callback. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>annodex</em>&nbsp;</td><td>an ANNODEX* handle </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the associated user_data </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="anx_read.h::anx_get_read_stream_user_data" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void* anx_get_read_stream_user_data </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>annodex</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve the user_data associated with an attached AnxReadStream callback. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>annodex</em>&nbsp;</td><td>an ANNODEX* handle </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the associated user_data </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="anx_read.h::anx_get_read_track_user_data" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void* anx_get_read_track_user_data </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>annodex</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve the user_data associated with an attached AnxReadTrack callback. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>annodex</em>&nbsp;</td><td>an ANNODEX* handle </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the associated user_data </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="anx_read.h::anx_read" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> long anx_read </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>annodex</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>long&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read from an annodex opened with <a class="el" href="anx__general_8h.html#a3">anx_open()</a> or <a class="el" href="anx__general_8h.html#a4">anx_open_stdio()</a>. 
<p>
The annodex is automatically parsed and relevant read callbacks are called, stopping when the required number of bytes have been read, or earlier if any of the read callbacks returned other than ANX_CONTINUE. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>annodex</em>&nbsp;</td><td>an ANNODEX* handle </td></tr>
    <tr><td valign=top><em>n</em>&nbsp;</td><td>count of bytes to read </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the count of bytes actually read </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="anx_read.h::anx_read_input" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> long anx_read_input </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>annodex</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned char *&nbsp;</td>
          <td class="mdname" nowrap> <em>buf</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>long&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Input data from a memory buffer into an annodex. 
<p>
Usually the annodex would have been created with <a class="el" href="anx__general_8h.html#a5">anx_new()</a>. The annodex is automatically parsed and relevant read callbacks are called, stopping when the required number of bytes have been read, or earlier if any of the read callbacks returned other than ANX_CONTINUE. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>annodex</em>&nbsp;</td><td>an ANNODEX* handle </td></tr>
    <tr><td valign=top><em>buf</em>&nbsp;</td><td>a memory buffer containing data to input </td></tr>
    <tr><td valign=top><em>n</em>&nbsp;</td><td>count of bytes to input </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the count of bytes actually input </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="anx_read.h::anx_set_read_clip_callback" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int anx_set_read_clip_callback </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>annodex</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="anx__read_8h.html#a3">AnxReadClip</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>read_clip</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>user_data</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the function to call each time a clip is parsed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>annodex</em>&nbsp;</td><td>an ANNODEX* handle </td></tr>
    <tr><td valign=top><em>read_clip</em>&nbsp;</td><td>the callback to call </td></tr>
    <tr><td valign=top><em>user_data</em>&nbsp;</td><td>Arbitrary data you wish to pass to your callback </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="anx_read.h::anx_set_read_head_callback" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int anx_set_read_head_callback </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>annodex</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="anx__read_8h.html#a2">AnxReadHead</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>read_head</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>user_data</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the function to call when the head element is read. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>annodex</em>&nbsp;</td><td>an ANNODEX* handle </td></tr>
    <tr><td valign=top><em>read_head</em>&nbsp;</td><td>the callback to call </td></tr>
    <tr><td valign=top><em>user_data</em>&nbsp;</td><td>Arbitrary data you wish to pass to your callback </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="anx_read.h::anx_set_read_raw_callback" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int anx_set_read_raw_callback </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>annodex</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="anx__read_8h.html#a4">AnxReadRaw</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>read_raw</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>user_data</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the function to call each time a raw data packet is read. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>annodex</em>&nbsp;</td><td>an ANNODEX* handle </td></tr>
    <tr><td valign=top><em>read_raw</em>&nbsp;</td><td>the callback to call </td></tr>
    <tr><td valign=top><em>user_data</em>&nbsp;</td><td>Arbitrary data you wish to pass to your callback </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="anx_read.h::anx_set_read_stream_callback" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int anx_set_read_stream_callback </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>annodex</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="anx__read_8h.html#a0">AnxReadStream</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>read_stream</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>user_data</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the function to call each time an 'Annodex' stream header is parsed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>annodex</em>&nbsp;</td><td>an ANNODEX* handle </td></tr>
    <tr><td valign=top><em>read_stream</em>&nbsp;</td><td>the callback to call </td></tr>
    <tr><td valign=top><em>user_data</em>&nbsp;</td><td>Arbitrary data you wish to pass to your callback </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="anx_read.h::anx_set_read_track_callback" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int anx_set_read_track_callback </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>annodex</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="anx__read_8h.html#a1">AnxReadTrack</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>read_track</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>user_data</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the function to call each time an 'AnxData' track header is parsed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>annodex</em>&nbsp;</td><td>an ANNODEX* handle </td></tr>
    <tr><td valign=top><em>read_track</em>&nbsp;</td><td>the callback to call </td></tr>
    <tr><td valign=top><em>user_data</em>&nbsp;</td><td>Arbitrary data you wish to pass to your callback </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="anx_read.h::anx_set_user_data" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int anx_set_user_data </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="anx__types_8h.html#a0">ANNODEX</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>annodex</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>user_data</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Associate arbitrary data with read callbacks. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>annodex</em>&nbsp;</td><td>an ANNODEX* handle </td></tr>
    <tr><td valign=top><em>user_data</em>&nbsp;</td><td>a pointer to a user defined object to be passed to each of the read callbacks. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat May 22 19:44:48 2004 for libannodex by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.5 </small></address>
</body>
</html>
